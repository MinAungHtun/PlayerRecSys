<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NBA Performance Recommender System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; background-color: #f4f7f6; color: #333; }
        header { background-color: #1d428a; color: #ffffff; padding: 20px; text-align: center; }
        nav { background-color: #c9082a; padding: 10px 0; text-align: center; }
        nav a { color: #ffffff; margin: 0 15px; text-decoration: none; font-weight: bold; }
       .container { padding: 20px; max-width: 1200px; margin: auto; }
        h1, h2 { color: #1d428a; }
        /* Style for the Recommendation Tool */
        #recommender-tool { background-color: #ffffff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); margin-bottom: 20px; }
       .input-group label { display: block; margin-bottom: 8px; font-weight: bold; }
       .input-group select,.input-group button { padding: 10px; margin-right: 10px; border-radius: 4px; border: 1px solid #ccc; }
        #recommendation-results table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        #recommendation-results th, #recommendation-results td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        #recommendation-results th { background-color: #f2f2f2; color: #333; }
        /* Style for the Roster Table (Initial View) */
        #roster-table { max-height: 400px; overflow-y: scroll; margin-top: 20px; background-color: #fff; border-radius: 8px; padding: 10px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        #roster-table table { width: 100%; border-collapse: collapse; }
        #roster-table th, #roster-table td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; font-size: 0.9em; }
        #roster-table th { position: sticky; top: 0; background-color: #1d428a; color: #ffffff; cursor: pointer; }
       .top-performer { background-color: #fffacd; font-weight: bold; }
        
        /* Utility Classes for Explanation */
       .explanation { margin-top: 20px; padding: 15px; border-left: 5px solid #c9082a; background-color: #fff0f0; }
    </style>
</head>
<body>

    <header>
        <h1>NBA Content-Based Player Performance Recommender</h1>
    </header>

    <nav>
        <a href="#recommender">Recommender Tool</a>
        <a href="#roster">Performance Roster</a>
        <a href="#analytics">Analytics Overview</a>
    </nav>

    <div class="container">
        
        <section id="analytics">
            <h2>Analytics Overview</h2>
            <p><strong>Methodology:</strong> This system uses Content-Based Filtering (CBF) to find similar player performance instances. Similarity is calculated using **Cosine Similarity** on a normalized feature vector derived from the Game Score (GmSc) components.</p>
            <p><strong>GmSc Correlation:</strong> Performance instances in winning efforts (W) show a significantly higher average GmSc (~12.60) compared to those in losing efforts (L) (~9.15). [1]</p>
            <div id="top-performers-summary">
                <h3>Top 10 Performances (By GmSc)</h3>
                </div>
        </section>

        <section id="recommender">
            <h2 id="recommender-header">Recommender Tool</h2>
            <div id="recommender-tool">
                <p><strong>Select a Performance to Find Similar Matches:</strong></p>
                <div class="input-group">
                    <label for="target-performance">Target Performance (Player - Date - GmSc)</label>
                    <select id="target-performance" style="width: 70%;"></select>
                    <button onclick="runRecommendation()">Find Similar Performances (Top 10)</button>
                </div>
                
                <div class="explanation">
                    <strong>Model Rationale:</strong> The recommendation favors performances with a similar *statistical profile* (pattern of scoring, rebounding, and efficiency) rather than just raw volume. Turnovers and inefficient shooting are heavily penalized in the underlying metrics.
                </div>
                
                <div id="recommendation-results">
                    <h3>Recommendation Results</h3>
                </div>
            </div>
        </section>

        <section id="roster">
            <h2>Full Performance Roster</h2>
            <p>Click table headers to sort the data. Filtered by performances with GmSc > 0.0.</p>
            <div id="roster-table">
                <table>
                    <thead>
                        <tr>
                            <th data-column="Player">Player</th>
                            <th data-column="Tm">Team</th>
                            <th data-column="Date">Date</th>
                            <th data-column="GmSc">GmSc</th>
                            <th data-column="PTS">PTS</th>
                            <th data-column="AST">AST</th>
                            <th data-column="TRB">TRB</th>
                            <th data-column="MP">MP</th>
                        </tr>
                    </thead>
                    <tbody id="roster-body">
                        </tbody>
                </table>
            </div>
        </section>
        
    </div>

    <script>
        let rawData =;
        let sortedColumn = 'GmSc';
        let sortDirection = 'desc';

        // Columns used for similarity calculation (Game Score components are proxies)
        // These are intentionally simplified for a purely front-end prototype.
        const FEATURE_COLUMNS =;

        // Utility function to load the CSV file
        function loadCSV() {
            // NOTE: This assumes 'database_24_25.csv' is in the same directory for GitHub Pages deployment.
            Papa.parse('database_24_25.csv', {
                download: true,
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: (results) => {
                    rawData = results.data.filter(row => row.GmSc > 0.0); // Filter out non-productive games for relevance
                    initializeUI(rawData);
                },
                error: (error) => {
                    console.error("Error loading CSV:", error);
                    alert("Failed to load data. Ensure 'database_24_25.csv' is in the root directory.");
                }
            });
        }

        // Feature Scaling / Normalization (Per Minute)
        function getFeatureVector(row) {
            const vector = {};
            const minutes = parseFloat(row.MP); 
            // Handle missing or zero minutes to prevent division by zero, though filtration helps here.
            const mp = (minutes > 0)? minutes : 1; 

            // Basic feature set normalized by minutes played (MP)
            vector.PTS = parseFloat(row.PTS) / mp;
            vector.FGA = parseFloat(row.FGA) / mp; // Penalizes volume shooting
            vector.ThreeP = parseFloat(row['3P']) / mp;
            vector.ORB = parseFloat(row.ORB) / mp;
            vector.DRB = parseFloat(row.DRB) / mp;
            vector.AST = parseFloat(row.AST) / mp;
            vector.STL = parseFloat(row.STL) / mp;
            vector.BLK = parseFloat(row.BLK) / mp;
            vector.TOV = parseFloat(row.TOV) / mp; // Penalizes turnovers
            vector.PF = parseFloat(row.PF) / mp; // Penalizes fouls

            return vector;
        }

        // Core Similarity Calculation (Cosine Similarity)
        function cosineSimilarity(vecA, vecB) {
            const features = Object.keys(vecA);
            let dotProduct = 0;
            let magnitudeA = 0;
            let magnitudeB = 0;

            for (const feature of features) {
                const valA = vecA[feature] |

| 0;
                const valB = vecB[feature] |

| 0;

                dotProduct += valA * valB;
                magnitudeA += valA * valA;
                magnitudeB += valB * valB;
            }

            magnitudeA = Math.sqrt(magnitudeA);
            magnitudeB = Math.sqrt(magnitudeB);

            if (magnitudeA === 0 |

| magnitudeB === 0) return 0;

            return dotProduct / (magnitudeA * magnitudeB);
        }
        
        // Populate the dropdown menu and initial tables
        function initializeUI(data) {
            const dropdown = document.getElementById('target-performance');
            const topPerformersSummary = document.getElementById('top-performers-summary');
            
            // Populate Dropdown with Top Performers (to make selection meaningful)
            const sortedByGmSc = [...data].sort((a, b) => parseFloat(b.GmSc) - parseFloat(a.GmSc));
            const top10 = sortedByGmSc.slice(0, 10);
            
            let topPerformersHTML = `<table><thead><tr><th>Rank</th><th>Player</th><th>Date</th><th>GmSc</th></tr></thead><tbody>`;
            top10.forEach((row, index) => {
                const option = document.createElement('option');
                const uniqueId = `${row.Player}-${row.Date}-${row.GmSc}`;
                option.value = uniqueId;
                option.textContent = `${row.Player} (${row.Date}) - GmSc: ${row.GmSc}`;
                dropdown.appendChild(option);

                topPerformersHTML += `<tr class="top-performer"><td>${index + 1}</td><td>${row.Player}</td><td>${row.Date}</td><td>${row.GmSc}</td></tr>`;
            });
            topPerformersHTML += `</tbody></table>`;
            topPerformersSummary.innerHTML = '<h3>Top 10 Performances (By GmSc)</h3>' + topPerformersHTML;

            // Display full roster
            renderRoster(data);

            // Set a default target recommendation (The highest GmSc performer)
            if (top10.length > 0) {
                dropdown.value = `${top10.Player}-${top10.Date}-${top10.GmSc}`;
                runRecommendation();
            }
        }
        
        // Roster Rendering and Sorting Logic
        function renderRoster(data) {
            const tbody = document.getElementById('roster-body');
            tbody.innerHTML = '';

            const dataToSort = [...data];

            // Sorting logic
            dataToSort.sort((a, b) => {
                let aVal = a[sortedColumn];
                let bVal = b[sortedColumn];

                if (!isNaN(parseFloat(aVal)) && isFinite(aVal)) {
                    aVal = parseFloat(aVal);
                    bVal = parseFloat(bVal);
                } else if (typeof aVal === 'string') {
                    // For strings, ignore case and compare
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                }

                if (aVal < bVal) return sortDirection === 'asc'? -1 : 1;
                if (aVal > bVal) return sortDirection === 'asc'? 1 : -1;
                return 0;
            });

            dataToSort.forEach(row => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${row.Player}</td>
                    <td>${row.Tm}</td>
                    <td>${row.Data}</td>
                    <td>${parseFloat(row.GmSc).toFixed(1)}</td>
                    <td>${row.PTS}</td>
                    <td>${row.AST}</td>
                    <td>${row.TRB}</td>
                    <td>${row.MP}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        // Attach sort listeners
        document.querySelectorAll('#roster-table th').forEach(header => {
            header.addEventListener('click', function() {
                const column = this.getAttribute('data-column');
                if (sortedColumn === column) {
                    sortDirection = (sortDirection === 'asc')? 'desc' : 'asc';
                } else {
                    sortedColumn = column;
                    sortDirection = 'desc'; // Default descending for stats
                }
                renderRoster(rawData);
            });
        });

        // Main Recommendation Function
        function runRecommendation() {
            const selectedValue = document.getElementById('target-performance').value;
            const = selectedValue.split('-');

            const targetPerformance = rawData.find(row => 
                row.Player === targetPlayer && 
                row.Date === targetDate && 
                parseFloat(row.GmSc).toFixed(1) === parseFloat(targetGmSc).toFixed(1)
            );

            if (!targetPerformance) {
                document.getElementById('recommendation-results').innerHTML = '<h3>Error: Target performance not found.</h3>';
                return;
            }

            const targetVector = getFeatureVector(targetPerformance);
            const similarities =;

            rawData.forEach(candidate => {
                // Skip comparing the item to itself
                const candidateId = `${candidate.Player}-${candidate.Date}-${candidate.GmSc}`;
                if (candidateId === selectedValue) return;

                const candidateVector = getFeatureVector(candidate);
                const similarityScore = cosineSimilarity(targetVector, candidateVector);
                
                // Optional: Apply a small boost for winning games (Re-ranking Stage 3 Concept)
                let finalScore = similarityScore;
                if (candidate.Res === 'W') {
                    finalScore += 0.05; // Small boost for context/winning performance
                }
                
                similarities.push({
                    player: candidate.Player,
                    team: candidate.Tm,
                    date: candidate.Date,
                    gmSc: candidate.GmSc,
                    similarity: finalScore,
                    stats: candidate
                });
            });

            // Rank and retrieve top 10 (excluding the small boost for display simplicity)
            similarities.sort((a, b) => b.similarity - a.similarity);
            const topRecommendations = similarities.slice(0, 10);

            // Render Results
            const resultsDiv = document.getElementById('recommendation-results');
            let tableHTML = `
                <h3>Recommendations for: ${targetPlayer} (${targetDate}, GmSc: ${targetGmSc})</h3>
                <p>Top 10 statistically similar performance profiles based on normalized box score metrics.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>Team</th>
                            <th>Date</th>
                            <th>GmSc</th>
                            <th>Similarity Score</th>
                            <th>Result</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            topRecommendations.forEach((rec, index) => {
                tableHTML += `
                    <tr>
                        <td>${index + 1}</td>
                        <td>${rec.player}</td>
                        <td>${rec.team}</td>
                        <td>${rec.date}</td>
                        <td>${parseFloat(rec.gmSc).toFixed(1)}</td>
                        <td>${(rec.similarity * 100).toFixed(2)}%</td>
                        <td>${rec.stats.Res}</td>
                    </tr>
                `;
            });

            tableHTML += `</tbody></table>`;
            resultsDiv.innerHTML = tableHTML;
        }

        // Start the application when the page loads
        document.addEventListener('DOMContentLoaded', loadCSV);
    </script>
</body>
</html>
